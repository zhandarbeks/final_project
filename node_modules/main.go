package main

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"log"
	"net/http"
	"net/smtp"
	"regexp"
	"strings"
	"time"
	"flag"
	"path/filepath"
	"sync"
	"text/template"

	"github.com/golang-jwt/jwt/v4"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var mongoClient *mongo.Client
var usersCollection *mongo.Collection
var ctx, cancel = context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()


const jwtSecret = "06df829c80fa7a07d6b4e219a0ea683dacb6cf6f652db490417893179adf5525"

type User struct {
	Username          string `bson:"username"`
	HashedPassword    string `bson:"hashed_password"`
	Role              string `bson:"role"`
	Confirmed         bool   `bson:"confirmed"`
	ConfirmationToken string `bson:"confirmationToken"`
}

var r = newRoom()

func main() {
	var err error
	mongoClient, err = mongo.Connect(context.TODO(), options.Client().ApplyURI("mongodb://localhost:27017"))
	defer mongoClient.Disconnect(context.TODO())
	if err != nil {
		log.Fatalf("Error connecting to MongoDB: %v", err)
	}
	usersCollection = mongoclient.Database("auth_system").Collection("users")
	var addr = flag.String("addr", ":8080", "The address of the application.")
	flag.Parse() // parse the flags

	fs := http.FileServer(http.Dir("./static"))
	http.Handle("/", fs)
	// WebSocket room handler
	http.Handle("/room", r)
	go r.run()

	http.HandleFunc("/api/register", register)
	http.HandleFunc("/api/confirm", confirmEmail)
	http.HandleFunc("/api/login", login)
	http.HandleFunc("/api/logout", logout)
	http.HandleFunc("/api/protected", protected)
	http.HandleFunc("/api/chat", chat)

	log.Println("Server started at http://localhost:8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

func register(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Invalid method", http.StatusMethodNotAllowed)
		return
	}

	username := r.FormValue("username")
	password := r.FormValue("password")

	if len(username) < 8 || len(password) < 8 {
		http.Error(w, "Username and password must be at least 8 characters", http.StatusNotAcceptable)
		return
	}

	if !isValidEmail(username) {
		http.Error(w, "Invalid email address", http.StatusBadRequest)
		return
	}

	var existingUser User
	err := usersCollection.FindOne(ctx, bson.M{"username": username}).Decode(&existingUser)
	if err == nil {
		http.Error(w, "User already exists", http.StatusConflict)
		return
	}

	hashedPassword, err := hashPassword(password)
	if err != nil {
		http.Error(w, "Error hashing password", http.StatusInternalServerError)
		return
	}

	confirmationToken := generateToken()

	newUser := User{
		Username:          username,
		HashedPassword:    hashedPassword,
		Role:              "user",
		Confirmed:         false,
		ConfirmationToken: confirmationToken,
	}
	_, err = usersCollection.InsertOne(ctx, newUser)
	if err != nil {
		http.Error(w, "Error registering user", http.StatusInternalServerError)
		return
	}

	go sendConfirmationEmail(username, confirmationToken)
	fmt.Fprintln(w, "Registration successful! Please check your email to confirm your account.")
}

func isValidEmail(email string) bool {
	regex := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
	re := regexp.MustCompile(regex)
	return re.MatchString(email)
}

func confirmEmail(w http.ResponseWriter, r *http.Request) {
	token := r.URL.Query().Get("token")
	if token == "" {
		http.Error(w, "Invalid token", http.StatusBadRequest)
		return
	}

	var user User
	err := usersCollection.FindOneAndUpdate(
		ctx,
		bson.M{"confirmationToken": token},
		bson.M{"$set": bson.M{"confirmed": true, "confirmationToken": ""}},
		options.FindOneAndUpdate().SetReturnDocument(options.After),
	).Decode(&user)
	
	if err != nil || user.Username == "" 	 {
		log.Printf("Confirmation failed: token '%s' not found or expired.", token)
		http.Error(w, "Invalid or expired token", http.StatusBadRequest)
		return
	}

	log.Printf("Email confirmed for username '%s'.", user.Username)
	fmt.Fprintln(w, "Email confirmed successfully! You can now log in.")
}

func login(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Invalid method", http.StatusMethodNotAllowed)
		return
	}

	username := r.FormValue("username")
	password := r.FormValue("password")

	var user User
	err := usersCollection.FindOne(ctx, bson.M{"username": username}).Decode(&user)
	if err != nil {
		log.Printf("Login failed: user not found for username '%s'.", username)
		http.Error(w, "Invalid username or password", http.StatusUnauthorized)
		return
	}

	if !user.Confirmed {
		log.Printf("Login failed: email not confirmed for username '%s'.", username)
		http.Error(w, "Email not confirmed. Please check your email.", http.StatusUnauthorized)
		return
	}

	if !checkPassword(password, user.HashedPassword) {
		log.Printf("Login failed: incorrect password for username '%s'.", username)
		http.Error(w, "Invalid username or password", http.StatusUnauthorized)
		return
	}

	token, err := generateJWT(user.Username, user.Role)
	if err != nil {
		log.Printf("Error generating token for username '%s': %v", username, err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "Authorization",
		Value:   token,
		Expires: time.Now().Add(24 * time.Hour),
	})

	log.Printf("Login successful for username '%s'.", username)
	fmt.Fprintln(w, "Login successful!")
}

func logout(w http.ResponseWriter, r *http.Request) {
	http.SetCookie(w, &http.Cookie{
		Name:    "Authorization",
		Value:   "",
		Expires: time.Now().Add(-1 * time.Hour),
	})
	fmt.Fprintln(w, "Logout successful!")
}

func protected(w http.ResponseWriter, r *http.Request) {
	tokenCookie, err := r.Cookie("Authorization")
	if err != nil {
		http.Error(w, "Unauthorized", http.StatusUnauthorized)
		return
	}

	username, role, err := validateJWT(tokenCookie.Value)
	if err != nil {
		http.Error(w, "Invalid token", http.StatusUnauthorized)
		return
	}

	fmt.Fprintf(w, "Welcome, %s! Your role is: %s.", username, role)
}

func generateToken() string {
	token := make([]byte, 32)
	_, _ = rand.Read(token)
	return hex.EncodeToString(token)
}

func sendConfirmationEmail(email, token string) {
	from := "fergumz.70@gmail.com"
	password := "cxnfodqgjvbwufsn"
	to := []string{email}
	subject := "Confirm your registration"
	body := fmt.Sprintf("Click the link to confirm your registration: http://localhost:8080/api/confirm?token=%s", token)

	msg := fmt.Sprintf("From: %s\nTo: %s\nSubject: %s\n\n%s", from, strings.Join(to, ","), subject, body)
	auth := smtp.PlainAuth("", from, password, "smtp.gmail.com")

	err := smtp.SendMail("smtp.gmail.com:587", auth, from, to, []byte(msg))
	if err != nil {
		log.Printf("Error sending email: %v", err)
	}
}

func generateJWT(username, role string) (string, error) {
	claims := jwt.MapClaims{
		"username": username,
		"role":     role,
		"exp":      time.Now().Add(24 * time.Hour).Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(jwtSecret))
}

func validateJWT(tokenString string) (string, string, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		return []byte(jwtSecret), nil
	})

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok || !token.Valid {
	    return "", "", err
	}

	username, usernameOk := claims["username"].(string)
	role, roleOk := claims["role"].(string)

	if !usernameOk || !roleOk {
    	return "", "", fmt.Errorf("invalid token claims")
	}

	return username, role, nil
}

// templ represents a single template
type templateHandler struct {
	once     sync.Once
	filename string
	templ    *template.Template
}

// ServeHTTP handles the HTTP request.
func (t *templateHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	t.once.Do(func() {
		t.templ = template.Must(template.ParseFiles(filepath.Join("templates", t.filename)))
	})
	t.templ.Execute(w, r)
}
